/**
 * Provides a qualitative interpretation and color for a given score.
 * @param {number} score - A score from 0 to 100.
 * @returns {{text: string, color: string}}
 */
export const getScoreInterpretation = (score) => {
  if (score >= 80) {
    return { text: 'Alto', color: 'success.main' };
  }
  if (score >= 50) {
    return { text: 'Medio', color: 'warning.main' };
  }
  return { text: 'Bajo', color: 'error.main' };
};

/**
 * Calculates the progress and score for a given list of statements.
 * @param {Array} items - An array of statement objects, each with an 'id'.
 * @param {Object} scores - An object where keys are statement IDs and values are the scores.
 * @returns {{progress: number, score: number, total: number, answered: number}}
 */
export const calculateProgress = (items, scores = {}) => {
  if (!items || items.length === 0) {
    return { progress: 0, score: 0, total: 0, answered: 0 };
  }

  let totalScore = 0;
  let answeredCount = 0;

  items.forEach((item) => {
    if (scores[item.id] !== undefined && scores[item.id] !== null) {
      answeredCount++;
      if (scores[item.id] === 1) {
        totalScore += scores[item.id];
      }
    }
  });

  const applicableItems = items.filter((item) => scores[item.id] !== 0.5);
  const totalPossibleScore = applicableItems.length;

  const progress = (answeredCount / items.length) * 100;
  const scorePercentage =
    totalPossibleScore > 0 ? (totalScore / totalPossibleScore) * 100 : 0;

  return {
    progress: Math.round(progress),
    score: Math.round(scorePercentage),
    total: items.length,
    answered: answeredCount,
  };
};

/**
 * Generates a hierarchical summary: overall, by type, and by subtype.
 * @param {Array} matrix - The vulnerability matrix structure.
 * @param {Object} scores - The current scores from the user.
 * @returns {{overall: Object, byType: Object}}
 */
export const getSummary = (matrix, scores = {}) => {
  const allEnunciados = matrix.flatMap((tipo) =>
    tipo.subtipos.flatMap((subtipo) => subtipo.enunciados)
  );

  const overallProgress = calculateProgress(allEnunciados, scores);
  const overall = {
    ...overallProgress,
    interpretation: getScoreInterpretation(overallProgress.score),
  };

  const byType = {};
  matrix.forEach((tipo) => {
    const typeEnunciados = tipo.subtipos.flatMap((sub) => sub.enunciados);
    const typeProgress = calculateProgress(typeEnunciados, scores);

    const subtypesData = {};
    tipo.subtipos.forEach((subtipo) => {
      const subtypeProgress = calculateProgress(subtipo.enunciados, scores);
      subtypesData[subtipo.nombre] = {
        ...subtypeProgress,
        interpretation: getScoreInterpretation(subtypeProgress.score),
      };
    });

    byType[tipo.tipo] = {
      summary: {
        ...typeProgress,
        interpretation: getScoreInterpretation(typeProgress.score),
      },
      subtypes: subtypesData,
    };
  });

  return { overall, byType };
};
